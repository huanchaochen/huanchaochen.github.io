---
layout: post
title: 开发知识
date:   2020-12-05 23:15:23 +0800
category: tutorial
thumbnail: /style/image/thumbnail.jpg
icon: note
---

# 操作系统

## 重点

### **基础**

- ★★★ 进程与线程的本质区别、以及各自的使用场景。
- ★☆☆ 进程状态。
- ★★★ 进程调度算法的特点以及使用场景。
- ★☆☆ 线程实现的方式。
- ★★☆ 协程的作用。
- ★★☆ 常见进程同步问题。
- ★★★ 进程通信方法的特点以及使用场景。
- ★★★ 死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁。
- ★★★ 虚拟内存的作用，分页系统实现虚拟内存原理。
- ★★★ 页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法。
- ★★★ 比较分页与分段的区别。
- ★★★ 分析静态链接的不足，以及动态链接的特点。

### **Linux**

- ★★☆ 文件系统的原理，特别是 inode 和 block。数据恢复原理。
- ★★★ 硬链接与软链接的区别。
- ★★☆ 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。
- ★★★ 僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因。

# 进程和线程

## 进程与线程的区别

Ⅰ 拥有资源

进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

Ⅱ 调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

Ⅲ 系统开销

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

Ⅳ 通信方面

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

## 进程调度算法

### 批处理系统

- 先来先服务 first-come first-serverd（FCFS）
- 短作业优先 shortest job first（SJF）
- 最短剩余时间优先 shortest remaining time next（SRTN）

### 交互式系统

- 时间片轮转：将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。
- 优先级调度：为每个进程分配一个优先级，按优先级进行调度。
- 多级反馈队列：多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

# 死锁

## 原因

为了保证多进程（或多线程）的安全性，一个进程在使用临界资源（必须互斥访问的资源）时需要对临界资源加锁，从而防止和其它进程同时使用该临界资源。如果有其它进程已经在使用该临界资源，那么就无法完成加锁操作，会处于一直等待的状态。在访问临界资源之后，需要对临界资源进行解锁，从而把临界资源让出来给其它进程使用。

但是当满足某些条件时，导致无法对资源完成解锁操作，那么其它想要访问这些资源的进程就无法完成加锁操作，而处于一直等待的状态。

## 死锁的必要条件

- 互斥
- 占有和等待
- 不可抢占
- 环路等待

## 死锁预防

破坏以上4个条件

## 死锁代码

```java
public class DeadLock {
    public static final String LOCK_1 = "lock1";
    public static final String LOCK_2 = "lock2";

    public static void main(String[] args) {
        Thread threadA = new Thread(() -> {
            try {
                while (true) {
                    synchronized (DeadLock.LOCK_1) {
                        System.out.println(Thread.currentThread().getName() + " 锁住 lock1");
                        Thread.sleep(1000);
                        synchronized (DeadLock.LOCK_2) {
                            System.out.println(Thread.currentThread().getName() + " 锁住 lock2");
                        }
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        });

        Thread threadB = new Thread(() -> {
            try {
                while (true) {
                    synchronized (DeadLock.LOCK_2) {
                        System.out.println(Thread.currentThread().getName() + " 锁住 lock2");
                        Thread.sleep(1000);
                        synchronized (DeadLock.LOCK_1) {
                            System.out.println(Thread.currentThread().getName() + " 锁住 lock1");
                        }
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        });

        threadA.start();
        threadB.start();
    }
}
```

# 虚拟内存

### 作用

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

### 页面置换算法

**LRU（Least Recently Used）**

LRU 将最近最久未使用的页面换出。

为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

**NRU, Not Recently Used**

**FIFO, First In First Out**

### 分页和分段的比较

- 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
- 地址空间的维度：分页是一维地址空间，分段是二维的。
- 大小是否可以改变：页的大小不可变，段的大小可以动态改变。
- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

## 链接

### 静态链接的不足

静态库有以下两个问题：

- 当静态库更新时那么整个程序都要重新进行链接；
- 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

### 动态链接的特点

- 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
- 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

## 文件系统

- inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；
- block：记录文件的内容，文件太大时，会占用多个 block。

### 硬链接与软链接的区别

链接简单地说是一种文件共享的方式。linux系统下提供ln指令来进行文件链接。文件链接主要分为硬链接和软链接。

区别：

- 硬链接： 与普通文件没什么不同，`inode` 都指向同一个文件在硬盘中的区块
- 软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径

### 常用命令

**grep**

g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印

例如查看特定的线程：ps aux | grep threadx

**cat**

取得文件内容。

## cat [-AbEnTv] filename
-n ：打印出行号，连同空白行也会有行号，-b 不会

### 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。

孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。

由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

### 僵尸进程

一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。

僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。

系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。